{
  "nodes": [
    {
      "id": 1,
      "label": "非线性方程的数值解法",
      "title": "非线性方程的数值解法",
      "level": 0,
      "document": "## 非线性方程求解：一场与弯曲世界的智慧对话\n\n**目标读者：** 对数学好奇，渴望理解“为什么”和“怎么想出来”的学习者。\n\n**核心理念：** 公式是思考的结晶，而非思考的起点。我们重走发现之路。\n\n---\n\n### 第一章：问题起源——当直线世界遇到弯曲现实\n\n#### **1.1 世界的“弯曲”本质**\n想象你是个17世纪的科学家：\n* 伽利略告诉你：**自由落体**距离 `s = (1/2)gt²` - 漂亮！这是**线性**的（t²也是简单二次）。\n* 开普勒告诉你：**行星轨道**满足 `M = E - e sin(E)`（开普勒方程）- 天哪！`E` 藏在正弦函数里，**无法用代数方法解出**！\n\n**核心困境：** 绝大多数描述真实世界的方程（物理、工程、经济、生物）都是**非线性**的！像 `x³ + 2x - 5 = 0` 或 `cos(x) = x` 这样看似简单的方程，往往没有像 `x = (-b ± √(b²-4ac))/2a` 那样的“万能钥匙”。\n\n> **物理直觉：** 线性方程像笔直的铁轨，一眼望到头；非线性方程像蜿蜒的山路，你站在起点，根本看不见终点藏在哪个弯后面。\n\n#### **1.2 人类的朴素尝试：“猜”与“试”**\n面对 `cos(x) = x`，你会怎么做？\n1. 试试 `x = 0`：`cos(0) = 1`，`0 ≠ 1` - 太大了。\n2. 试试 `x = 1`：`cos(1) ≈ 0.54`，`1 ≠ 0.54` - 还是太大。\n3. 试试 `x = 0.5`：`cos(0.5) ≈ 0.88`，`0.5 ≠ 0.88` - `0.88 > 0.5`。\n4. 试试 `x = 0.7`：`cos(0.7) ≈ 0.76`，`0.7 ≠ 0.76` - 还是 `0.76 > 0.7`。\n5. 试试 `x = 0.8`：`cos(0.8) ≈ 0.70`，`0.8 ≠ 0.70` - 现在 `0.70 < 0.8`！\n\n**发现！** 在 `x=0.7` 时，`cos(x) > x`；在 `x=0.8` 时，`cos(x) < x`。解肯定在 `0.7` 和 `0.8` 之间！\n\n> **思考火花：** 人类本能地使用了**试错法**，并敏锐地捕捉到了**函数值符号的变化**！这孕育了第一个强大的数值方法。\n\n---\n\n### 第二章：二分法——稳扎稳打的“排除大师”\n\n#### **2.1 灵感来源：缩小包围圈**\n* **面对问题：** 已知解在区间 `[a, b]` 内（比如 `[0.7, 0.8]`），如何精确找到它？\n* **自然灵感：** 想想玩“猜数字”游戏（1-100）。猜50，大了？那目标在1-50。猜25，小了？那目标在25-50... **不断排除一半错误答案！**\n\n#### **2.2 数学化：区间折半与符号侦查**\n1. **前提：** 函数 `f(x)` 在 `[a, b]` 上**连续** (想象一条不断开的曲线)，且 `f(a) * f(b) < 0` (符号相反，保证穿过零点)。\n2. **第一步：** 计算中点 `c = (a + b) / 2`。\n3. **侦查：** 计算 `f(c)`。\n    * 如果 `f(c) = 0`，太幸运！`c` 就是解。\n    * 如果 `f(c) * f(a) < 0`，解在 `[a, c]` 内 → 新区间 `[a, c]`。\n    * 如果 `f(c) * f(b) < 0`，解在 `[c, b]` 内 → 新区间 `[c, b]`。\n4. **重复：** 把新区间当作新的 `[a, b]`，重复步骤1-3。\n5. **停止：** 当区间长度小于你想要的精度 (比如 `0.001`) 时，中点 `c` 就是近似解。\n\n> **比喻：** 二分法像一个严谨的侦探。嫌疑范围 `[a, b]`。他找中点 `c` 问话 (`f(c)`)。根据回答 (`f(c)`的符号)，他总能排除掉一半的嫌疑人区域。范围越来越小，真凶（解）无处可逃！\n\n#### **2.3 优缺点：乌龟的智慧**\n* **优点：** 超级稳定！只要初始区间满足条件，**保证**收敛。简单可靠。\n* **缺点：** 收敛**速度慢**。想提高1位精度，差不多要折半10次 (因为 `2¹⁰ ≈ 1024`)。像一只坚定但步伐缓慢的乌龟。\n\n---\n\n### 第三章：牛顿法——借力打力的“切线冲刺手”\n\n#### **3.1 灵感来源：以直代曲，步步逼近**\n* **面对问题：** 二分法太慢！尤其当函数在某点附近“比较直”时，有没有更快的办法？\n* **自然灵感：** 想象你站在山坡 (`f(x)`曲线)上，目标是谷底 (`f(x)=0`处)。你环顾四周：\n    * 当前点 `x₀`，高度 `f(x₀)`。\n    * 脚下的**坡度**（**导数** `f'(x₀)`）告诉你哪边是下坡方向。\n    * **直觉决策：** 沿着当前**最陡的下坡方向（负梯度方向）走一步**，应该能更快接近谷底！但走多远？步子太大会冲过头，太小又慢。\n\n#### **3.2 数学化：切线的力量**\n1. **核心洞察：** 在 `x₀` 点，用**切线**这条直线 (`y = f(x₀) + f'(x₀)(x - x₀)`) 去**近似**弯曲的 `f(x)`。\n2. **目标转移：** 求 `f(x)=0` 难，求它的切线 `=0` 容易！令切线方程为零：\n    `f(x₀) + f'(x₀)(x - x₀) = 0`\n3. **解“假”方程：** 解出 `x`：\n    `x = x₀ - f(x₀) / f'(x₀)`\n4. **迭代：** 这个 `x` 比 `x₀` 更接近真实零点！把它作为新的起点 `x₁`，重复步骤1-3：\n    `x_{n+1} = x_n - f(x_n) / f'(x_n)`\n\n> **比喻：** 牛顿法像一个视力不好但懂微积分的高尔夫球手。站在 `x₀`，他看不到球洞 (`f(x)=0`)，但他能看到脚下的地形（切线）。他沿着切线方向用力一击（计算 `x₁ = x₀ - f(x₀)/f'(x₀)`），球落在 `x₁`。虽然没进洞，但更近了！他在 `x₁` 再看地形，再击球... 几次精准击打后，球进洞了！\n\n#### **3.3 优缺点：猎豹的风险**\n* **优点：** 收敛速度**极快**！如果初始值选得好，精度位数**翻倍增长** (二次收敛)。像迅猛的猎豹。\n* **缺点：**\n    * 需要计算**导数** `f'(x)`。\n    * 初始值 `x₀` 要选好。如果初始点附近地形复杂（导数接近0，或者函数剧烈震荡），可能会“冲过头”导致**发散**或**震荡**。\n    * 不保证收敛（不像二分法有保底）。\n\n> **物理直觉：** 导数 `f'(x)` 是速度/斜率。牛顿法本质是利用当前的速度信息，预测“零点的位置”，并勇敢地跳到预测点。预测准（函数局部接近线性）就快；预测歪（函数弯曲或坡度平缓）就惨了。\n\n---\n\n### 第四章：不动点迭代——自己映射自己的“平衡魔术”\n\n#### **4.1 灵感来源：寻找自我映射的平衡点**\n* **面对问题：** 有些方程很难直接处理，能否换个角度？\n* **自然灵感：** 想象一个反馈系统：输出值作为下一轮的输入。比如调节淋浴水温：\n    * 当前水温 `xₙ` (太冷)。\n    * 你根据冷热调整阀门：`g(xₙ) = xₙ + 调节量`。\n    * 新水温 `x_{n+1} = g(xₙ)`。\n    * 目标：找到一个水温 `x*`，使得 `x* = g(x*)` —— 你不需要再调节了！这就是**不动点**。它对应原方程 `f(x) = x - g(x) = 0` 的解。\n\n#### **4.2 数学化：构造收敛的迭代函数**\n1. **方程变形：** 把 `f(x) = 0` 巧妙地改写成 `x = g(x)` 的形式。\n    * 例如 `cos(x) = x` 天然是 `x = cos(x)` → `g(x) = cos(x)`。\n    * 例如 `x² - 2 = 0` 可以写成 `x = x - (x² - 2)` (很差的 `g(x)`)，或 `x = (x + 2/x)/2` (很好的 `g(x)`)。\n2. **迭代过程：** 从一个猜测 `x₀` 开始：\n    `x₁ = g(x₀)`\n    `x₂ = g(x₁)`\n    `...`\n    `x_{n+1} = g(x_n)`\n3. **期望：** 如果序列 `{xₙ}` 收敛到某个值 `x*`，那么 `x* = g(x*)`，即 `x*` 是 `f(x)=0` 的解。\n\n> **比喻：** 不动点迭代像在照一面神奇的镜子。你站在镜子前 (`x₀`)。镜子里的映像是 `g(x₀)` (`x₁`)。你走到映像的位置 (`x₁`)。再看新映像 `g(x₁)` (`x₂`)。如此反复... 如果这面镜子是“收敛镜”，你会被一步步引导到一个**魔法平衡点** `x*`。站在这里，你的位置和镜中映像**完全重合** (`x* = g(x*)`)！这个点就是原方程的解。镜子的设计 (`g(x)`的选择) 决定了你是否能找到这个点。\n\n#### **4.3 收敛性：镜子的魔法**\n* **关键：** `g(x)` 的设计和性质决定了迭代是否收敛、收敛多快。\n* **收敛条件：**\n    * `g(x)` 在解 `x*` 附近**连续**。\n    * `g(x)` 在解 `x*` 附近的**导数的绝对值** `|g'(x)| < 1` (且越小收敛越快)。\n* **优缺点：**\n    * 优点：形式灵活，有时非常简单（如 `x = cos(x)`）。\n    * 缺点：构造好的 `g(x)` 需要技巧；收敛性依赖于 `g(x)` 和初始值；可能收敛慢或不收敛。\n\n---\n\n### 第五章：方法对比与实战选择\n\n| 方法         | 核心思想                     | 需要什么?        | 速度     | 稳定性     | 典型应用场景                     |\n| :----------- | :--------------------------- | :--------------- | :------- | :--------- | :------------------------------- |\n| **二分法**   | 区间折半，符号侦查           | 区间 `[a, b]` (满足 `f(a)f(b)<0`) | 慢 (线性) | **极高** (保证收敛) | 快速找大致范围；函数性质不明；求可靠解 |\n| **牛顿法**   | 利用切线近似，迭代冲刺       | 初始点 `x₀`, `f(x)`, `f'(x)` | **极快** (二次) | 中等 (依赖初始点/导数) | 函数光滑、导数易算、初始点接近真解 |\n| **不动点迭代**| 构造 `x=g(x)`，寻找平衡点    | 初始点 `x₀`, 合适的 `g(x)` | 可变 (线性或更快) | 中等 (依赖 `g(x)` 和初始点) | 方程天然或容易写成 `x=g(x)` 形式；其他方法导数计算困难 |\n\n**如何选择？**\n1. **先找“家”：** 用二分法（或画图/试值）快速确定解所在的**小区间**。这是最可靠的第一步！\n2. **加速冲刺：** 如果在小区间内函数比较“乖”（光滑、导数不为零），拿出牛顿法，享受它的高速！(记得检查导数 `f'(x)` 是否容易计算)。\n3. **另辟蹊径：** 如果方程能漂亮地写成 `x = g(x)` 且你感觉 `g(x)` 会收敛（比如 `|g'(x)|` 可能小于1），试试不动点迭代。有时它非常简单。\n\n---\n\n### 结语：思想的回响\n\n这些数值方法，并非冰冷的公式，而是人类智慧对非线性世界发起的温柔挑战：\n\n* **二分法**教会我们：**耐心排除错误**，步步为营，终达目标。这是逻辑的力量。\n* **牛顿法**启迪我们：**利用局部信息**（导数），勇敢预测，迭代修正。这是微积分的锋芒。\n* **不动点迭代**揭示：**巧妙变换视角**（`x = g(x)`），在自我映射中寻找动态平衡。这是转化的艺术。\n\n下次当你调用 `fsolve()` 或点击“求解”按钮时，请记得背后这场跨越世纪的思维接力。它们诞生于行星轨道的计算、桥梁应力的分析、经济模型的推演... 是理解这个复杂弯曲世界的钥匙。\n\n**动手吧！** 拿起纸笔或代码，用二分法找 `x = cos(x)`，用牛顿法解 `x² - 2 = 0`，感受这些方法的脉搏。记住，最好的理解，来自重现前人的思考路径。祝你在这场与非线性世界的对话中，收获智慧与乐趣！",
      "modelId": "model_1748848200623"
    },
    {
      "id": 3,
      "label": "不动点迭代",
      "title": "不动点迭代",
      "level": 1,
      "document": "好的，同学们！今天我们要一起探索一个非常强大又充满数学美感的概念——**不动点迭代**。别被名字吓到，它背后的想法其实非常直观，就像玩一个“找位置”的游戏。我们从一个真实的问题开始，一步步推导，看看古人（或者当时的数学家）是怎么想到这个方法的，以及它为什么如此有用。\n\n**课程名称：** 寻找“魔法平衡点”——不动点迭代的奇妙之旅\n\n**目标：** 理解不动点迭代的核心思想、工作原理、收敛条件，并能运用它解决简单的方程求根问题。\n\n---\n\n**一、 背景：我们遇到了什么麻烦？**\n\n想象一下，你是一位生活在17世纪的天文学家（比如开普勒）。你正在研究行星运动的规律，发现了一个描述行星位置的关键方程：\n`x = cos(x)`\n（别担心为什么是这个方程，它可能是某个复杂物理定律简化后的结果）。\n\n你的任务很简单：**找到一个实数 `x`，使得这个等式成立。** 也就是说，让 `x` 和它的余弦值 `cos(x)` 相等。\n\n**问题来了：**\n1.  **这个方程看起来简单，但你能直接“解”出 `x` 吗？** 试试看：`x - cos(x) = 0`。这不像 `2x - 3 = 0` 那样能轻易求出 `x=1.5`。代数方法在这里似乎失效了！\n2.  **画图法？** 好主意！我们可以把 `y = x` 和 `y = cos(x)` 这两条线画在坐标系里。它们的交点就是我们要找的解（`x` 使得 `x = cos(x)`）。\n    *   你画出来会发现，在 `x=0` 附近，直线 `y=x` 和曲线 `y=cos(x)` 确实有一个交点（大约在 0.7 到 0.8 之间）。但这只能给我们一个**大概的位置**。\n3.  **我们需要精确值！** 行星轨道计算可不能马虎，差之毫厘，谬以千里。怎么办？\n\n**痛点：** **很多重要的方程（尤其在物理、工程、经济学中）无法用简单的代数方法求解（没有“求根公式”）。我们需要一种系统的、能用纸笔（或后来的计算机）计算来逼近精确解的方法。**\n\n---\n\n**二、 灵感闪现：从“猜猜看”到“步步逼近”**\n\n面对 `x = cos(x)` 这个难题，数学家们开始思考：既然不能一步到位，能不能一步步靠近答案？\n\n**一个朴素的想法（试试看）：**\n1.  我**猜**一个解 `x₀` (Initial Guess - 初始猜测)。比如，从图上看交点大概在0.7到0.8之间，我猜 `x₀ = 0.7`。\n2.  现在，我把猜的这个 `0.7` 代入方程的**右边**：计算 `cos(x₀) = cos(0.7)`。\n    *   拿出计算器（或者查表，古人真这么干！）：`cos(0.7) ≈ 0.7648`。\n3.  咦？这个计算出来的 `0.7648` 和我猜的 `0.7` **不相等**。但是，它是不是比 `0.7` **更接近**我们看到的那个交点呢？让我们看看：\n    *   猜 `x₀ = 0.7` -> 计算 `x₁ = cos(0.7) ≈ 0.7648`\n4.  好，现在我不再用 `0.7` 了，我觉得 `0.7648` 可能更好一点。我把它作为新的起点：计算 `cos(x₁) = cos(0.7648)`。\n    *   `cos(0.7648) ≈ 0.7216`。\n5.  现在我有 `x₂ = 0.7216`。再用它：`x₃ = cos(0.7216) ≈ 0.7506`。\n6.  继续：`x₄ = cos(0.7506) ≈ 0.7311`\n7.  `x₅ = cos(0.7311) ≈ 0.7443`\n8.  `x₆ = cos(0.7443) ≈ 0.7355`\n9.  `x₇ = cos(0.7355) ≈ 0.7415`\n10. `x₈ = cos(0.7415) ≈ 0.7377`\n11. `x₉ = cos(0.7377) ≈ 0.7402`\n12. `x₁₀ = cos(0.7402) ≈ 0.7385`\n13. ... (继续下去)\n\n**观察这个序列：**\n`0.7 -> 0.7648 -> 0.7216 -> 0.7506 -> 0.7311 -> 0.7443 -> 0.7355 -> 0.7415 -> 0.7377 -> 0.7402 -> 0.7385 -> ...`\n\n**哇！它们好像在来回震荡，但震荡的幅度越来越小，似乎在向某个中间值靠拢！** 比如 `0.7385` 和 `0.7402` 已经很接近了。如果我们继续算下去，这个序列的值会越来越稳定，最终几乎不再变化（或者变化非常非常小）。那个最终它稳定下来的值，就是我们要找的解！\n\n**核心思想浮现：** 如果我们能把一个求根问题 `f(x) = 0` **巧妙地变形**成一个等价的形式 `x = g(x)`，然后从一个猜测 `x₀` 出发，反复计算 `x_{n+1} = g(x_n)`，如果这个序列能**稳定**下来（收敛），那么它稳定下来的那个值 `x*` 就一定满足 `x* = g(x*)`，也就是满足原始的 `f(x*) = 0`。这个点 `x*` 就叫做函数 `g(x)` 的一个**不动点**（Fixed Point）—— 因为当 `x` 取这个值时，`g` 的作用不会让它“动”（改变），`g(x*) = x*`。我们通过**迭代**（Iteration）的方式逼近了这个不动点。所以这个方法就叫**不动点迭代法**。\n\n---\n\n**三、 构建数学语言：把灵感变成工具**\n\n现在我们把刚才的“灵光一现”规范化、一般化。\n\n1.  **目标问题：** 求方程 `f(x) = 0` 的根。\n2.  **关键变形：** 将 `f(x) = 0` **等价地**改写成 `x = g(x)` 的形式。\n    *   例如：`f(x) = x - cos(x) = 0` -> `x = cos(x)`。这里 `g(x) = cos(x)`。\n    *   变形方式**不唯一**！比如 `x - cos(x) = 0` 也可以变形为 `x = x + (x - cos(x))`，即 `g(x) = x + (x - cos(x))`。**不同的 `g(x)` 会导致迭代过程完全不同（可能收敛，可能发散）！** 选择好的 `g(x)` 是成功的关键。\n3.  **迭代公式：** 从一个初始猜测 `x₀` 开始，反复应用：\n    `x_{n+1} = g(x_n)` `(n = 0, 1, 2, 3, ...)`\n4.  **不动点：** 如果序列 `{x₀, x₁, x₂, ..., x_n, ...}` **收敛**到某个极限 `x*`，即 `lim_{n->∞} x_n = x*`，并且函数 `g(x)` 在 `x*` 处连续，那么我们有：\n    `x* = lim_{n->∞} x_{n+1} = lim_{n->∞} g(x_n) = g(lim_{n->∞} x_n) = g(x*)`\n    这就证明了 `x*` 满足 `x* = g(x*)`，即 `x*` 是 `g(x)` 的一个不动点，也是原方程 `f(x)=0` 的一个根。\n5.  **核心问题：** 这个序列 `{x_n}` 一定收敛吗？如果不收敛（发散或者震荡），我们的努力就白费了。**什么条件下它才会收敛？**\n\n---\n\n**四、 深入探索：为什么有时成功（收敛），有时失败（发散）？**\n\n回到我们最初的例子 `g(x) = cos(x)`。为什么序列会稳定下来？观察迭代过程，数值在来回跳动但幅度减小。\n\n**物理直觉（橡皮筋比喻）：**\n想象 `x = g(x)` 的解是地图上的一个“魔法平衡点”。你站在点 `x_n`。\n*   函数 `g` 像一根**有弹性的指示带**，它从 `x_n` 指向 `g(x_n)`（也就是你的下一个位置 `x_{n+1}`）。\n*   **如果这根“指示带”的拉力比较“温和”**（意味着 `g(x)` 在平衡点附近变化比较“平缓”，斜率绝对值小于1），当你靠近平衡点时，它轻轻把你拉过去，你最终会稳稳停在平衡点 `x*`（收敛）。\n*   **如果这根“指示带”的拉力非常“猛烈”**（意味着 `g(x)` 在平衡点附近变化很“剧烈”，斜率绝对值大于1），它可能会把你猛地拉过平衡点，甩到另一边，然后又用更大的力气把你甩回来，甚至甩得更远。你会在平衡点附近来回震荡，幅度越来越大，或者直接飞得无影无踪（发散）。\n\n**数学刻画（收敛的充分条件）：**\n为了让迭代 `x_{n+1} = g(x_n)` 收敛到不动点 `x*`，一个关键条件是：**函数 `g(x)` 在不动点 `x*` 附近不能变化得太快。**\n\n更精确地说（**不动点定理**，简化版）：\n假设 `x*` 是 `g(x)` 的一个不动点 (`g(x*) = x*`)。如果存在一个包含 `x*` 的区间 `[a, b]`，并且在这个区间内：\n1.  `g(x)` 是连续的。(橡皮筋是连续的，没有断裂)\n2.  `g(x)` 的值域也在 `[a, b]` 内。(橡皮筋的指示不会把你拉出这个区域)\n3.  `g(x)` 的导数 `g'(x)` 存在，且满足 `|g'(x)| ≤ K < 1` (其中 `K` 是一个小于1的常数)。**(核心条件！橡皮筋的“最大拉力强度”小于1)**\n\n那么，对于该区间 `[a, b]` 内的**任意**初始猜测 `x₀`，由迭代 `x_{n+1} = g(x_n)` 产生的序列 `{x_n}` 都**一定收敛**到不动点 `x*`。并且，收敛速度与 `K` 的大小有关，`K` 越小，收敛越快。\n\n**理解 `|g'(x*)| < 1` 的重要性：**\n*   在不动点 `x*` 附近，`g(x)` 的行为主要由它的导数 `g'(x*)` 决定。\n*   `|g'(x*)| < 1` 意味着在 `x*` 附近，函数 `g(x)` 的**变化率小于1**。当你接近 `x*` 时，每一步迭代带来的改变 `|x_{n+1} - x*| ≈ |g'(x*)||x_n - x*|` 会小于上一步离 `x*` 的距离 `|x_n - x*|`，误差在**缩小**。\n*   如果 `|g'(x*)| > 1`，则 `|x_{n+1} - x*| ≈ |g'(x*)||x_n - x*| > |x_n - x*|`，误差在**放大**，导致发散。\n*   如果 `|g'(x*)| = 1`，情况比较复杂，可能收敛也可能发散，或者收敛得很慢。\n\n**例子验证：**\n*   我们的 `g(x) = cos(x)`：\n    *   不动点 `x* ≈ 0.739` (前面迭代逼近的结果)。\n    *   导数 `g'(x) = -sin(x)`。\n    *   在 `x* ≈ 0.739` 处，`|g'(x*)| = | -sin(0.739) | ≈ | -0.673 | = 0.673 < 1`。**满足收敛条件！** 所以我们的迭代成功了。\n*   **试试一个会失败的变形：** 把原方程 `x - cos(x) = 0` 变形为 `x = 3cos(x)`，即 `g(x) = 3cos(x)`。\n    *   同一个不动点 `x*` 应该仍然满足 `x* = 3cos(x*)`？不对！`x = cos(x)` 的解显然不满足 `x = 3cos(x)` (除非 `x=0`，但 `0 ≠ cos(0)=1`)。我们需要找新 `g(x)` 的不动点。\n    *   画出 `y=x` 和 `y=3cos(x)`。`3cos(x)` 在 -3 到 3 之间震荡，`y=x` 是直线。它们在 `x≈1.5` 和 `x≈-1.5` 附近有交点？假设我们关心 `x≈1.5` 附近的点。\n    *   导数 `g'(x) = -3sin(x)`。\n    *   在可能的交点附近 (比如 `x=1.5`)，`|g'(1.5)| = | -3sin(1.5) | ≈ | -3 * 0.997 | ≈ 2.991 > 1`！**不满足收敛条件！**\n    *   让我们迭代试试：取 `x₀ = 1.5`\n        `x₁ = 3cos(1.5) ≈ 3 * 0.0707 ≈ 0.212`\n        `x₂ = 3cos(0.212) ≈ 3 * 0.977 ≈ 2.931`\n        `x₃ = 3cos(2.931) ≈ 3 * (-0.979) ≈ -2.937`\n        `x₄ = 3cos(-2.937) ≈ 3 * (-0.979) ≈ -2.937` (近似不动点，但不是原问题的解！)\n    *   序列在 `-2.937` 附近稳定了，但 `-2.937 ≠ cos(-2.937) ≈ -0.979`，不满足原方程 `x = cos(x)`。它收敛到了 `g(x)=3cos(x)` 的一个不动点，但不是我们想要的那个。而且从 `x₀=1.5` 开始，它直接跳到另一边去了。这就是发散（收敛到错误解，或者震荡/发散）的例子。\n\n---\n\n**五、 总结与应用：强大的“平衡点”搜寻术**\n\n**核心思想回顾：**\n1.  **目标：** 解方程 `f(x) = 0`。\n2.  **变形：** 等价地写成 `x = g(x)` **(关键步骤！选择合适的 `g` 很重要)**。\n3.  **迭代：** 猜一个起点 `x₀`，反复计算 `x_{新} = g(x_{旧})`。\n4.  **不动点：** 如果序列收敛到 `x*`，那么 `x* = g(x*)` 且 `f(x*) = 0`。\n5.  **收敛条件 (关键！)：** 在不动点 `x*` 附近，函数 `g(x)` 的**变化不能太剧烈**，数学上要求 `|g'(x*)| < 1`（或满足更严格的不动点定理条件）。\n\n**为什么强大？**\n*   **简单易行：** 只需要重复计算一个函数 `g(x)`。\n*   **通用性强：** 适用于大量无法直接求根的方程。\n*   **计算机友好：** 非常适合编程实现，让计算机自动进行重复计算。\n*   **思想深刻：** 不动点的概念在数学（函数方程、动力系统）、物理（平衡态、相变）、计算机科学（程序语义、递归）、经济学（均衡点）等领域无处不在。理解它是打开这些领域大门的钥匙之一。\n\n**应用举例：**\n1.  **求平方根：** 求 `a` 的平方根，即解 `x² - a = 0`。\n    *   变形：`x² - a = 0` -> `x² = a` -> `x = a / x`？(这个 `g(x)=a/x` 不好，导数 `|g'(x)| = |a|/x²`，在根号a处等于1，且容易震荡)。\n    *   **更好的变形：** `x = (1/2)(x + a/x)` (想想怎么来的？由 `x²=a` -> `2x² = x² + a` -> `x = (1/2)(x + a/x)`)。这个 `g(x) = (1/2)(x + a/x)` 在 `x* = √a` 处的导数 `g'(x*) = 0` (自己验证一下？)，**远小于1**，收敛非常快！这就是著名的**牛顿迭代法**求平方根的精髓（牛顿法是不动点迭代的一个特例和优化）。\n2.  **解超越方程：** 如我们开始的 `x = cos(x)`，或者 `e^x + x = 0` (变形为 `x = -e^x` 或 `x = ln(-x)`，注意定义域和收敛性)。\n3.  **解线性方程组 (间接)：** 一些大型线性方程组求解方法（如 Jacobi 迭代法、Gauss-Seidel 迭代法）本质上也是构造不动点迭代。\n\n**给你的挑战：**\n1.  用不动点迭代法求解 `x = tan(x)` 在 `(π/2, 3π/2)` 区间内的解（提示：变形为 `x = arctan(x) + π`，注意收敛性分析）。\n2.  尝试用 `x = (1/2)(x + a/x)` 迭代计算 `√2`，取 `x₀ = 1`，计算几步，感受它飞快的收敛速度！\n\n**最后的话：**\n不动点迭代的魅力在于它**将寻找静态解（不动点）的过程转化为一个动态的、逐步逼近的序列**。它告诉我们，即使不能一步登天，通过精心设计（选择合适的 `g(x)`）和持续努力（迭代），我们总能逼近甚至到达那个“魔法平衡点”。记住庞加莱的话：“数学是用不同的名字称呼同一事物。” 不动点，正是连接方程求解、函数行为、系统平衡等诸多概念的桥梁之一。下次当你遇到一个难解的方程时，不妨想想：“我能把它变成一个寻找‘魔法平衡点’的游戏吗？” 祝你在数学的探索中找到更多美妙的平衡点！",
      "modelId": "model_1748848200623"
    },
    {
      "id": 4,
      "label": "Jacobi 迭代法",
      "title": "Jacobi 迭代法",
      "level": 2,
      "document": "好的，同学们！今天我们穿越回19世纪，化身成解决巨型方程组的“数学工程师”，一起探索一个聪明又优雅的方法——**Jacobi迭代法**。别被名字吓到，它的核心思想其实非常物理、非常直观，就像一群邻居互相传话，最终达成共识！\n\n**核心目标：** 解决一个包含很多未知数（比如几十个、几百个甚至更多）的**大型线性方程组**。\n\n**想象一下这个场景 (背景与问题)：**\n\n你是一位热力工程师，正在模拟一个复杂金属板上的**温度分布**。你把金属板划分成了100x100个小格子（共10,000个点）。物理学告诉我们，**每个小格子的稳定温度，等于它周围四个邻居格子温度的平均值！**（这是热传导方程离散化后的结果）。\n\n现在问题来了：\n1.  **每个格子的温度 (x₁, x₂, ..., x₁₀₀₀₀) 都是未知数！**\n2.  **每个格子都对应一个方程：`xᵢ = (xₙₒᵣₜₕ + xₛₒᵤₜₕ + xₑₐₛₜ + xᵥₑₛₜ)/4`** (对于内部格子)。\n3.  边界上的格子温度是固定的（已知条件）。\n\n你得到了一个**包含10,000个方程、10,000个未知数的超大型方程组！**写成矩阵形式就是 `Ax = b`（`A` 是巨大的系数矩阵，`x` 是未知温度向量，`b` 包含了边界条件信息）。\n\n**挑战：**\n*   用中学学的代入法或消元法？计算量爆炸！手工算几辈子也算不完，即使用计算机，对于超大矩阵，**高斯消元法**也会消耗巨大的内存和时间（时间复杂度 O(n³)）。\n*   我们需要一个更聪明、更省资源、并且能逐步逼近答案的方法！\n\n**灵感闪现 (物理直觉)：**\n\n回想一下那个物理规律：**每个点的温度等于邻居的平均值**。这给了我们一个绝妙的思路：\n\n1.  **初始猜猜看：** 我们不可能一下子知道所有点的精确温度。那就先**猜一个初始温度分布**吧！比如，假设整个板子都是室温25°C（除了边界）。这个初始猜测肯定不准。\n2.  **邻居间“传话”：** 基于当前的猜测，让每个格子去问问它的邻居：“嘿，你们现在是多少度？”然后，每个格子**根据邻居们当前报告的温度，重新计算自己的温度**：`新的xᵢ = (邻居北当前值 + 邻居南当前值 + 邻居东当前值 + 邻居西当前值)/4`。\n3.  **更新与迭代：** 所有格子都根据自己的邻居**同时更新**了自己的温度估计值（注意：是用**旧的**邻居值计算的）。我们用这组**更新后的值**作为下一次“传话”的基础。\n4.  **重复“传话”：** 重复步骤2和3。每一次“传话”和“更新”（称为一次**迭代**），每个格子的温度估计值都会根据最新的邻居信息调整一次。\n5.  **趋于共识：** 随着一轮轮的“传话”进行下去，你会发现温度估计值的变化越来越小。最终，当所有格子根据邻居算出的新值，和它自己当前的值**相差无几**（小于我们设定的一个很小的容忍误差）时，我们就认为它们基本达成“共识”了——这就是方程组的**近似解**！\n\n**这就是Jacobi迭代法的核心物理思想！它模拟了物理系统中信息（温度）通过局部相互作用（邻居平均）逐步传播并达到平衡状态的过程。**\n\n**构建数学语言 (从直觉到公式)：**\n\n现在，我们把这种邻居“传话”的思想，翻译成精确的数学公式。考虑一个通用的 `n` 元线性方程组：\n\n```\na₁₁x₁ + a₁₂x₂ + ... + a₁ₙxₙ = b₁\na₂₁x₁ + a₂₂x₂ + ... + a₂ₙxₙ = b₂\n...\naₙ₁x₁ + aₙ₂x₂ + ... + aₙₙxₙ = bₙ\n```\n\nJacobi迭代法的关键在于：**把第 `i` 个方程“改造”成 `xᵢ = ...` 的形式，并且等号右边只包含其他变量 `xⱼ (j ≠ i)`。**\n\n1.  **“解出” `xᵢ`：** 对于第 `i` 个方程，我们把包含 `xᵢ` 的项单独留在左边，其他所有项移到右边，然后两边同时除以 `aᵢᵢ` (前提是 `aᵢᵢ ≠ 0`！)：\n    `xᵢ = (1 / aᵢᵢ) * (bᵢ - [aᵢ₁x₁ + aᵢ₂x₂ + ... + aᵢᵢ₋₁xᵢ₋₁ + aᵢᵢ₊₁xᵢ₊₁ + ... + aᵢₙxₙ])`\n    **简化一下：**\n    `xᵢ = (bᵢ - Σⱼ₌₁, ⱼ≠ᵢⁿ aᵢⱼxⱼ) / aᵢᵢ`   `(公式1)`\n    *   `Σⱼ₌₁, ⱼ≠ᵢⁿ` 表示对 `j` 从1到 `n` 求和，但**跳过 `j = i`**。\n\n2.  **引入迭代：** 公式(1)告诉我们，如果知道其他所有 `xⱼ` 的值，就能精确算出 `xᵢ`。但我们不知道！所以我们要用**迭代**。\n    *   用 `xᵢ⁽ᵏ⁾` 表示第 `k` 次迭代后得到的 `xᵢ` 的估计值。\n    *   **Jacobi的智慧：在计算第 `k+1` 次迭代的 `xᵢ⁽ᵏ⁺¹⁾` 时，公式右边使用的 `xⱼ` 的值，全部取第 `k` 次迭代的结果 `xⱼ⁽ᵏ⁾`。** 并且，**所有 `xᵢ⁽ᵏ⁺¹⁾` 是同时（并行）计算出来的！**\n    **核心迭代公式诞生：**\n    `xᵢ⁽ᵏ⁺¹⁾ = (1 / aᵢᵢ) * (bᵢ - Σⱼ₌₁, ⱼ≠ᵢⁿ aᵢⱼxⱼ⁽ᵏ⁾)`   `(公式2 - Jacobi迭代公式)`\n    或者写得更清晰：\n    `xᵢ⁽ᵏ⁺¹⁾ = (bᵢ / aᵢᵢ) - (aᵢ₁/aᵢᵢ)x₁⁽ᵏ⁾ - (aᵢ₂/aᵢᵢ)x₂⁽ᵏ⁾ - ... - (aᵢᵢ₋₁/aᵢᵢ)xᵢ₋₁⁽ᵏ⁾ - (aᵢᵢ₊₁/aᵢᵢ)xᵢ₊₁⁽ᵏ⁾ - ... - (aᵢₙ/aᵢᵢ)xₙ⁽ᵏ⁾`\n\n**解读公式 (理解其精髓)：**\n\n*   **“根据上次大家的意见，重新计算我的意见”**：每个未知数 `xᵢ` 的新估计值 `xᵢ⁽ᵏ⁺¹⁾`，都是基于上一次迭代 (`k`) 中**所有其他未知数** `xⱼ⁽ᵏ⁾ (j≠i)` 的估计值计算出来的。\n*   **“同时更新”**：计算 `x₁⁽ᵏ⁺¹⁾`, `x₂⁽ᵏ⁺¹⁾`, ..., `xₙ⁽ᵏ⁺¹⁾` 时，使用的都是**旧的** `x⁽ᵏ⁾` 的值。计算完所有新值后，**一次性**用 `x⁽ᵏ⁺¹⁾` **完全替换掉** `x⁽ᵏ⁾`，再进行下一次迭代。这保证了计算的**并行性**。\n*   **“我的主导权”**：公式中除以 `aᵢᵢ` 突出了第 `i` 个方程中 `xᵢ` 自身系数的重要性。`aᵢᵢ` 越大（相对于其他 `aᵢⱼ`），意味着 `xᵢ` 的“发言权”越重，它的新值受邻居旧值的影响相对越小，迭代可能收敛得更快、更稳定。\n\n**矩阵视角 (简洁表达 - 了解即可)：**\n\n如果把所有未知数的第 `k` 次迭代估计值写成一个向量 `x⁽ᵏ⁾ = [x₁⁽ᵏ⁾, x₂⁽ᵏ⁾, ..., xₙ⁽ᵏ⁾]ᵀ`，Jacobi迭代可以写成：\n\n`x⁽ᵏ⁺¹⁾ = D⁻¹(b - (A - D)x⁽ᵏ⁾)`\n\n其中：\n*   `D` 是矩阵 `A` 的**对角部分**（即只有 `a₁₁, a₂₂, ..., aₙₙ` 的对角矩阵）。\n*   `D⁻¹` 是 `D` 的逆矩阵（因为 `D` 是对角阵，其逆就是每个对角元素取倒数）。\n*   `(A - D)` 就是矩阵 `A` **去掉对角线元素**后剩下的部分（包含所有非对角元素）。\n\n这个形式更紧凑，揭示了Jacobi迭代的本质：**用对角矩阵的逆去“修正”基于非对角部分和旧解计算出的残差**。但理解前面的分量形式(`公式2`)对于掌握思想更重要。\n\n**关键问题：它真的能“达成共识”吗？(收敛性)**\n\nJacobi迭代法不是万能的。它能否最终逼近到方程组的真实解 (`x*`)，取决于系数矩阵 `A` 的性质。最重要的条件是：\n\n1.  **对角占优 (Diagonal Dominance)：**\n    *   **严格行对角占优：** 对于矩阵 `A` 的每一行 `i`，都有 `|aᵢᵢ| > Σⱼ≠ᵢ |aᵢⱼ|`。即，每一行对角线元素的**绝对值**，严格大于该行所有**非对角线元素绝对值之和**。\n    *   **物理意义：** 每个未知数 `xᵢ` 在自己的方程里“占主导地位”。它的系数 (`|aᵢᵢ|`) 比它所有邻居系数 (`|aᵢⱼ|, j≠i`) 加起来的影响还要大。这保证了在“传话”过程中，每个点自己的“意见”不会被邻居们“带偏”太多，最终能稳定下来。在热传导例子中，这意味着每个格子的温度主要取决于自身（物理上通常成立）。\n2.  **对称正定 (Symmetric Positive Definite - SPD)：** 如果矩阵 `A` 是对称的 (`Aᵀ = A`) 且所有特征值都是正的，那么Jacobi迭代也可能收敛（虽然不一定比专门为SPD矩阵设计的共轭梯度法快）。\n\n**如果矩阵不满足收敛条件（比如某个点的邻居“嗓门”太大，比它自己还大），迭代过程可能会“吵翻天”，值上下震荡甚至无限增大，永远无法达成共识（发散）。**\n\n**总结Jacobi迭代法的步骤：**\n\n1.  **准备：**\n    *   给定方程组 `Ax = b`。\n    *   检查 `A` 是否对角元非零 (`aᵢᵢ ≠ 0`) 且（最好）满足行对角占优。\n    *   设定初始猜测解 `x⁽⁰⁾`（通常设为零向量或根据问题背景设定）。\n    *   设定最大迭代次数 `max_iter` 和容忍误差 `tolerance`。\n2.  **迭代 (对于 k = 0, 1, 2, ..., 直到满足停止条件)：**\n    *   **对所有 i (i=1 到 n) 同时计算：**\n        `xᵢ⁽ᵏ⁺¹⁾ = (bᵢ - Σⱼ₌₁, ⱼ≠ᵢⁿ aᵢⱼxⱼ⁽ᵏ⁾) / aᵢᵢ`\n        *   *注意：计算 `xᵢ⁽ᵏ⁺¹⁾` 时，右边使用的 `xⱼ` 都是 `xⱼ⁽ᵏ⁾`（上一次迭代的值）！*\n    *   **检查停止条件：**\n        *   计算某种误差度量，最常见的是**残差范数** `||r⁽ᵏ⁺¹⁾|| = ||b - Ax⁽ᵏ⁺¹⁾||` (比如计算其2-范数或无穷范数)，如果 `||r⁽ᵏ⁺¹⁾|| < tolerance`，则停止。\n        *   或者计算**解的变化量** `||x⁽ᵏ⁺¹⁾ - x⁽ᵏ⁾|| < tolerance`。\n        *   或者 `k+1 > max_iter`，则停止（防止无限循环）。\n3.  **输出：** 满足停止条件时的 `x⁽ᵏ⁺¹⁾` 作为方程组的近似解。\n\n**生动的比喻：**\n\n想象一个村庄里住着 `n` 户人家 (`x₁, x₂, ..., xₙ`)。每年年底，每户人家都要根据邻居们上一年的收入 (`xⱼ⁽ᵏ⁾`)，按照一个特定的公式（由 `aᵢⱼ` 和 `bᵢ` 决定）来计算自家新一年的预期收入 (`xᵢ⁽ᵏ⁺¹⁾`)。**所有人家都是在同一天、根据邻居去年的收入报告，独立计算自己的新年预期收入。** 计算完成后，大家同时公布新收入 (`x⁽ᵏ⁺¹⁾` 替换 `x⁽ᵏ⁾`)。年复一年（迭代），如果每户人家自己的“计算权重”（`aᵢᵢ`）足够大（主导），那么全村的收入预期最终会趋于一个稳定的、合理的分布（收敛到解）。如果某户人家太容易被邻居影响（`|aᵢᵢ|` 太小），全村收入预期可能会年年剧烈波动（发散）。\n\n**Jacobi vs. 它的表亲 Gauss-Seidel**\n\nJacobi迭代要求使用**完整的上一次迭代结果** (`x⁽ᵏ⁾`) 来计算所有新值 (`x⁽ᵏ⁺¹⁾`)。它的一个著名改进是**Gauss-Seidel迭代法**。Gauss-Seidel 的“传话”方式更“八卦”一点：\n*   它按照顺序计算 `x₁⁽ᵏ⁺¹⁾`, `x₂⁽ᵏ⁺¹⁾`, ..., `xₙ⁽ᵏ⁺¹⁾`。\n*   当计算 `xᵢ⁽ᵏ⁺¹⁾` 时，**如果 `x₁⁽ᵏ⁺¹⁾` 到 `xᵢ₋₁⁽ᵏ⁺¹⁾` 已经算出来了（即最新的值！），它就会用这些最新的值！** 只有下标大于 `i` 的变量才用旧值 `xⱼ⁽ᵏ⁾`。\n*   **公式：** `xᵢ⁽ᵏ⁺¹⁾ = (1 / aᵢᵢ) * (bᵢ - Σⱼ₌₁ⁱ⁻¹ aᵢⱼxⱼ⁽ᵏ⁺¹⁾ - Σⱼ₌ᵢ₊₁ⁿ aᵢⱼxⱼ⁽ᵏ⁾)`\n*   **优势：** 通常比Jacobi收敛得更快，因为利用了最新的信息。\n*   **劣势：** 计算 `xᵢ⁽ᵏ⁺¹⁾` 依赖于前面刚算出的 `x₁⁽ᵏ⁺¹⁾...xᵢ₋₁⁽ᵏ⁺¹⁾`，所以计算过程是**顺序的**，不像Jacobi那样天然适合并行计算。\n\n**动手试试看！(一个微型例子)**\n\n解方程组：\n```\n4x + y = 7\nx + 3y = 5\n```\n(真实解是 `x=1, y=1`，但我们假装不知道)\n\n1.  **写成Jacobi需要的格式 (`xᵢ = ...`):**\n    *   方程1: `4x + y = 7` => `x = (7 - y)/4`\n    *   方程2: `x + 3y = 5` => `y = (5 - x)/3`\n2.  **Jacobi迭代公式：**\n    *   `x⁽ᵏ⁺¹⁾ = (7 - y⁽ᵏ⁾)/4`\n    *   `y⁽ᵏ⁺¹⁾ = (5 - x⁽ᵏ⁾)/3`\n3.  **设定初值：** 猜 `x⁽⁰⁾ = 0, y⁽⁰⁾ = 0`\n4.  **迭代：**\n    *   **k=0:**\n        *   `x⁽¹⁾ = (7 - 0)/4 = 1.75`\n        *   `y⁽¹⁾ = (5 - 0)/3 ≈ 1.6667` (注意：计算 `y⁽¹⁾` 用的 `x⁽ᵏ⁾` 是 `x⁽⁰⁾=0`)\n    *   **k=1:**\n        *   `x⁽²⁾ = (7 - 1.6667)/4 ≈ (5.3333)/4 ≈ 1.3333` (用 `y⁽¹⁾≈1.6667`)\n        *   `y⁽²⁾ = (5 - 1.75)/3 ≈ (3.25)/3 ≈ 1.0833` (用 `x⁽¹⁾=1.75`)\n    *   **k=2:**\n        *   `x⁽³⁾ = (7 - 1.0833)/4 ≈ (5.9167)/4 ≈ 1.4792` (用 `y⁽²⁾≈1.0833`)\n        *   `y⁽³⁾ = (5 - 1.3333)/3 ≈ (3.6667)/3 ≈ 1.2222` (用 `x⁽²⁾≈1.3333`)\n    *   **k=3:**\n        *   `x⁽⁴⁾ = (7 - 1.2222)/4 ≈ (5.7778)/4 ≈ 1.4444`\n        *   `y⁽⁴⁾ = (5 - 1.4792)/3 ≈ (3.5208)/3 ≈ 1.1736`\n    *   **继续...** 你会发现 `x` 和 `y` 在 `1.4` 和 `1.2` 附近波动，并逐渐向 `(1, 1)` 靠近。计算更多步后会越来越精确。\n\n**为什么学习Jacobi？**\n\n1.  **概念基础：** 它是理解**迭代法**解决线性方程组的最基础、最直观的方法之一。理解了Jacobi，就很容易理解更高级的迭代法（如Gauss-Seidel, SOR）以及收敛性分析的概念。\n2.  **并行潜力：** 由于其同时更新的特性，Jacobi迭代在**并行计算**和**高性能计算**(HPC)领域仍有重要应用。计算每个新 `xᵢ⁽ᵏ⁺¹⁾` 的过程是完全独立的，可以在不同的CPU核心或计算节点上同时进行，只需要在每轮迭代结束时同步数据。\n3.  **特定场景有效：** 对于某些具有强对角优势或特殊结构（如拉普拉斯算子离散化得到的矩阵）的大型稀疏系统，Jacobi或其变种可能是有效的求解器或预处理器。\n\n**记住精髓：**\n\nJacobi迭代法，就是用一种**局部、同步、逐步更新**的方式，模拟物理系统中信息通过邻居交互传播达到平衡的过程，来解决那些庞大到无法直接“硬算”的方程组。它的核心公式 `xᵢ⁽ᵏ⁺¹⁾ = (bᵢ - Σⱼ≠ᵢ aᵢⱼxⱼ⁽ᵏ⁾) / aᵢᵢ` 完美体现了“**根据邻居上次的意见，重新计算我的意见**”这一朴素而强大的思想。下次当你面对一个巨大的网格或网络问题时，想想Jacobi，想想那些互相“传话”的邻居们！",
      "modelId": "model_1748848200623"
    },
    {
      "id": 5,
      "label": "Gauss-Seidel 迭代法",
      "title": "Gauss-Seidel 迭代法",
      "level": 2,
      "document": "以下是为您精心设计的Gauss-Seidel迭代法学习指南，采用「问题驱动叙事法」+「物理直觉可视化」的讲解方式：\n\n---\n\n### 咖啡杯里的数学奇迹：Gauss-Seidel迭代法探索手册\n**——像水流渗透岩石般自然求解方程组的智慧**\n\n---\n\n#### **第1章 被困在百万方程迷宫里的工程师**\n> **现实困境**：工程师小玲设计新型电池，需要求解包含10,000个方程的电路网络（形如 *A𝐱=𝐛*）。当她尝试用中学学的\"消元法\"时，计算机弹出警告：**内存不足**。  \n> 💡 **关键矛盾**：实际问题中矩阵*A*往往巨大且稀疏（99%元素为零），传统方法因存储中间变量崩溃。\n\n**物理直觉实验**：  \n取渔网悬挂四个重物（图1），求节点平衡位置：  \n```\n   (x1)----(x2)  \n    |  \\  /  |  \n    |   (x4) |  \n   (x3)-----/  \n```\n每个节点受力方程形如：  \n`x₁ = 0.3x₂ + 0.4x₃ + 0.1x₄ + b₁`  \n*这就是稀疏线性方程组的微型宇宙*\n\n---\n\n#### **第2章 人类最原始的求解智慧：迭代直觉**\n> **孩童的启发**：想象解谜游戏《密室逃脱》  \n> - 你被困有4扇门的房间（4个未知数）  \n> - 每扇门密码由其他门决定（方程关系）  \n> - **策略1（雅可比迭代）**：所有人同时猜密码 → 开门失败 → 交换新猜测 → 重复  \n> **策略2（Gauss-Seidel）**：第1人猜开门 → **立即广播新密码** → 第2人用最新信息猜 → 链式反应  \n\n**物理场景对比**：  \n- **雅可比迭代** → 多人独立计算，信息滞后  \n- **Gauss-Seidel** → 流水线作业，实时传递数据  \n\n---\n\n#### **第3章 从直觉到数学：Gauss-Seidel的诞生**\n**步骤1：解剖矩阵**  \n把系数矩阵拆解：*A = L + D + U*  \n- **L** (Lower)：下三角元素（流水线的前工序）  \n- **D** (Diagonal)：对角线（当前工作站）  \n- **U** (Upper)：上三角（后工序）  \n\n**步骤2：构建迭代流水线**  \n原始方程 *A𝐱=𝐛* 变形为：  \n```math\n(D+L)\\mathbf{x}^{(k+1)} = \\mathbf{b} - U\\mathbf{x}^{(k)}\n```\n**物理意义解读**：  \n> ✅ **左侧** *(D+L)*：用**刚更新**的𝑥₁,𝑥₂,...,𝑥ᵢ计算𝑥ᵢ₊₁（实时传递）  \n> ✅ **右侧** *b - Uxᵏ*：未更新的𝑥ᵢ₊₁,...,𝑥ₙ用**上轮旧值**（避免循环依赖）\n\n---\n\n#### **第4章 动手体验：电路平衡模拟**\n**案例**：求解渔网节点位置（简化3节点系统）：\n```\n方程：\nx₁ = 0.4x₂ + 0.2  \nx₂ = 0.5x₁ + 0.5x₃  \nx₃ = 0.3x₂ + 0.1\n```\n**迭代战争**：  \n- **雅可比军团**（同步更新）：  \n  ```python\n  # 所有人用旧值计算\n  x1_new = 0.4*x2_old + 0.2\n  x2_new = 0.5*x1_old + 0.5*x3_old\n  x3_new = 0.3*x2_old + 0.1\n  ```\n\n- **Gauss-Seidel特工队**（实时情报）：  \n  ```python\n  x1_new = 0.4*x2_old + 0.2        # 用x2旧值\n  x2_new = 0.5*x1_new + 0.5*x3_old # 用刚算的x1_new!\n  x3_new = 0.3*x2_new + 0.1        # 用刚算的x2_new!\n  ```\n\n**结果对比**（初始猜测[0,0,0]）：  \n| 迭代次数 | 雅可比 x₂ | GS x₂    |\n|----------|-----------|----------|\n| 1        | 0.0       | **0.5**  | ← 首轮即用新x₁  \n| 10       | 0.416     | **0.428**|  \n| 真解     | 0.4286    | 0.4286   |  \n> 💡 **关键洞察**：GS在第10轮时误差已比雅可比小10倍！\n\n---\n\n#### **第5章 为什么更快？水流渗透模型**\n想象干旱土地（图2）：  \n``` \n[干土区] → [湿土区] → [待润区]\n```\n- **雅可比**：在所有位置**同时**倒水 → 大量水流浪费  \n- **Gauss-Seidel**：从左到右**顺序**浇水 → 新湿润土地立即为右侧供水  \n\n**数学本质**：  \nGS迭代矩阵的谱半径 *ρ(G) < ρ(J)* → **误差衰减更快**  \n（*谱半径即最大特征值，决定收敛速度*）\n\n---\n\n#### **第6章 何时失效？警惕多米诺骨牌**\n**失效场景**：若对角元素过小（如 *x₁=2x₂+3x₃*）  \n→ 相当于骨牌间距过大，推力无法传递  \n\n**救星：对角占优条件**  \n若矩阵满足 *|aᵢᵢ| > Σ|aᵢⱼ|* (j≠i)，则保证收敛  \n> ✓ 物理意义：自身节点影响 > 邻居影响总和  \n> ✓ 工程意义：结构刚度矩阵天然满足此条件\n\n---\n\n#### **第7章 现代应用：从核电站到《堡垒之夜》**\n- 🎮 **游戏物理引擎**：实时计算百万弹簧网格变形  \n- 🌪️ **气象模拟**：用GS求解流体NS方程  \n- 🔋 **特斯拉电池设计**：电化学方程迭代求解  \n\n```mermaid\ngraph LR\nA[初始猜测x⁽⁰⁾] --> B{顺序更新}\nB --> C[用x₁⁽ᵏ⁺¹⁾算x₂⁽ᵏ⁺¹⁾]\nC --> D[用x₂⁽ᵏ⁺¹⁾算x₃⁽ᵏ⁺¹⁾]\nD --> E[误差<阈值？]\nE --否--> B\nE --是--> F[输出解]\n```\n\n---\n\n#### **进阶思考题**\n1. 若将GS的更新顺序从*1→2→3*改为*3→2→1*，结果相同吗？  \n2. 在分布式计算中，GS的实时更新策略会遇到什么挑战？  \n3. 观察松弛因子*ω*在SOR方法中如何加速收敛（提示：预测-校正机制）\n\n> **牛顿的启示**：”我之所以看得远，是因为站在巨人的肩膀上。“ Gauss-Seidel迭代法正是200年迭代智慧的结晶——它用**信息的实时流动**突破计算困局，至今仍在超级计算机中奔腾不息。\n\n--- \n**附录：Python实战代码**  \n```python\ndef gauss_seidel(A, b, max_iter=100):\n    n = len(b)\n    x = np.zeros(n)\n    for _ in range(max_iter):\n        for i in range(n):\n            sigma = sum(A[i][j] * x[j] for j in range(n) if j != i)\n            x[i] = (b[i] - sigma) / A[i][i]  # 立即覆盖旧值\n    return x\n```\n> 尝试修改为异步并行版本，体验工程取舍的奥妙！\n\n通过本指南，您已亲历从物理直觉→问题痛点→数学建模→算法实现的全链条思维训练。每个公式背后都是人类智慧的突围战，而Gauss-Seidel正是那柄刺穿计算迷雾的利刃。",
      "modelId": "model_1748848200623"
    },
    {
      "id": 6,
      "label": "弦截法",
      "title": "弦截法",
      "level": 0,
      "document": null,
      "modelId": "model_1748848200623"
    },
    {
      "id": 7,
      "label": "用不动点迭代法求解 x = tan(x) 在 (π/2, 3π/2) 区间内的解",
      "title": "用不动点迭代法求解 x = tan(x) 在 (π/2, 3π/2) 区间内的解",
      "level": 2,
      "document": "### 逐步解答：使用不动点迭代法求解 \\( x = \\tan(x) \\) 在 \\( (\\frac{\\pi}{2}, \\frac{3\\pi}{2}) \\) 区间内的解\n\n作为初学者，重要的是通过逻辑推导来理解问题解决的思维方式，而不是死记公式。我将一步步引导你完成整个过程，从分析问题到实现迭代。关键是要理解：不动点迭代法适用于方程 \\( x = g(x) \\) 的形式，通过迭代 \\( x_{n+1} = g(x_n) \\) 逼近解。但直接使用 \\( g(x) = \\tan(x) \\) 可能不收敛，我们需要根据函数性质选择合适的 \\( g(x) \\)。\n\n#### 步骤 1: 理解方程和区间\n- 给定方程 \\( x = \\tan(x) \\)，区间为 \\( (\\frac{\\pi}{2}, \\frac{3\\pi}{2}) \\)。\n- 分析 \\( \\tan(x) \\) 在区间内的行为：\n  - \\( \\tan(x) \\) 在 \\( x = \\frac{\\pi}{2} \\) 和 \\( x = \\frac{3\\pi}{2} \\) 处有渐近线（趋于无穷大），因为分母 \\( \\cos(x) = 0 \\)。\n  - 在 \\( (\\frac{\\pi}{2}, \\pi) \\)：\\( \\tan(x) \\) 从 \\( -\\infty \\) 增加到 0（因为 \\( x \\) 在第二象限，正切为负）。\n  - 在 \\( (\\pi, \\frac{3\\pi}{2}) \\)：\\( \\tan(x) \\) 从 0 增加到 \\( +\\infty \\)（因为 \\( x \\) 在第三象限正切为正）。\n- 方程 \\( x = \\tan(x) \\) 要求 \\( x \\) 等于其正切值。检查子区间：\n  - 在 \\( (\\frac{\\pi}{2}, \\pi) \\)：\\( x > 0 \\)（因为 \\( x > \\frac{\\pi}{2} \\approx 1.57 > 0 \\))，但 \\( \\tan(x) < 0 \\)，所以 \\( x \\neq \\tan(x) \\)。**无解**。\n  - 在 \\( (\\pi, \\frac{3\\pi}{2}) \\)：\\( x > 0 \\) 且 \\( \\tan(x) > 0 \\)。在 \\( x \\to \\pi^+ \\)，\\( \\tan(x) \\to 0^+ < x \\)（因为 \\( x \\approx 3.14 > 0 \\))；在 \\( x \\to (\\frac{3\\pi}{2})^- \\)，\\( \\tan(x) \\to +\\infty > x \\)（因为 \\( x \\approx 4.71 \\))。函数连续，由介值定理，**至少有一个解**。\n- 导数分析：\\( \\frac{d}{dx} \\tan(x) = \\sec^2(x) = 1 + \\tan^2(x) \\)。在 \\( (\\pi, \\frac{3\\pi}{2}) \\)，\\( \\sec^2(x) > 1 \\)（因为 \\( \\tan(x) > 0 \\))，而 \\( \\frac{d}{dx} x = 1 \\)，所以 \\( \\tan(x) \\) 增长比 \\( x \\) 快，**只有一个解**（因为 \\( \\tan(x) \\) 从下方穿过 \\( y = x \\) 一次）。\n\n**结论**：解在子区间 \\( (\\pi, \\frac{3\\pi}{2}) \\) 内，我们专注于此。\n\n#### 步骤 2: 选择合适的不动点迭代函数 \\( g(x) \\)\n- 直接使用 \\( g(x) = \\tan(x) \\) 迭代（即 \\( x_{n+1} = \\tan(x_n) \\)) 可能发散，因为：\n  - 在解 \\( x^* \\) 处，\\( g'(x) = \\sec^2(x) \\)，且 \\( x^* = \\tan(x^*) \\)，所以 \\( g'(x^*) = 1 + (x^*)^2 \\)。\n  - \\( x^* > \\pi > 3 \\)，故 \\( g'(x^*) > 1 + 3^2 = 10 > 1 \\)。不动点迭代要求 \\( |g'(x^*)| < 1 \\) 局部收敛，否则发散。\n- 需要重写方程 \\( x = \\tan(x) \\) 为等价形式 \\( x = g(x) \\)，使 \\( |g'(x)| < 1 \\)。\n- 利用正切函数的周期性：\\( \\tan(x) = \\tan(x - k\\pi) \\) 对所有整数 \\( k \\)。\n  - 解在 \\( (\\pi, \\frac{3\\pi}{2}) \\)，对应周期偏移 \\( k = 1 \\)（因为主值分支 \\( \\arctan(x) \\) 在 \\( (-\\frac{\\pi}{2}, \\frac{\\pi}{2}) \\)，需调整到第三象限）。\n  - 设 \\( y = x - \\pi \\)，则 \\( y \\in (0, \\frac{\\pi}{2}) \\)，方程变为：\n    \\[\n    x = \\tan(x) = \\tan(y + \\pi) = \\tan(y) \\implies y + \\pi = \\tan(y)\n    \\]\n  - 但 \\( y + \\pi = \\tan(y) \\) 仍不适合迭代（类似问题）。更优形式：\n    \\[\n    y = \\arctan(y + \\pi) \\quad \\text{或} \\quad x = \\arctan(x) + \\pi\n    \\]\n- 选择 \\( g(x) = \\arctan(x) + \\pi \\)：\n  - 验证在解点：如果 \\( x^* = \\tan(x^*) \\)，则 \\( x^* - \\pi = \\arctan(x^*) \\)（因为 \\( \\arctan \\) 返回主值），所以 \\( x^* = \\arctan(x^*) + \\pi \\) 成立。\n  - 导数：\\( g'(x) = \\frac{d}{dx} [\\arctan(x) + \\pi] = \\frac{1}{1 + x^2} \\)。\n    - \\( |g'(x)| = \\frac{1}{1 + x^2} \\leq 1 \\) 对所有 \\( x \\)，且在 \\( x \\neq 0 \\) 时严格小于 1。\n    - 在解 \\( x^* \\approx 4.5 \\)，\\( g'(x^*) \\approx \\frac{1}{1 + (4.5)^2} = \\frac{1}{21.25} \\approx 0.047 < 1 \\)，满足收敛条件。\n- 检查 \\( g(x) \\) 映射区间：\n  - \\( g(x) = \\arctan(x) + \\pi \\)，在 \\( x \\in (\\pi, \\frac{3\\pi}{2}) \\)。\n  - \\( \\arctan(x) \\) 单调增，值域 \\( (0, \\frac{\\pi}{2}) \\)，所以 \\( g(x) \\in (\\pi + 0, \\pi + \\frac{\\pi}{2}) = (\\pi, \\frac{3\\pi}{2}) \\)。\n  - 例如：\\( x = \\pi^+ \\approx 3.14 \\)，\\( g(x) \\approx \\arctan(3.14) + \\pi \\approx 1.26 + 3.14 = 4.40 > \\pi \\); \\( x \\to (\\frac{3\\pi}{2})^- \\approx 4.71 \\)，\\( g(x) \\to \\frac{\\pi}{2} + \\pi = \\frac{3\\pi}{2} \\)。所以 \\( g(x) \\) 将 \\( (\\pi, \\frac{3\\pi}{2}) \\) 映射到子集 \\( (4.4, \\frac{3\\pi}{2}) \\)，适合迭代。\n\n**结论**：使用 \\( g(x) = \\arctan(x) + \\pi \\) 进行迭代，即 \\( x_{n+1} = \\arctan(x_n) + \\pi \\)。\n\n#### 步骤 3: 设置初始值和迭代\n- 初始值 \\( x_0 \\) 选择：在区间 \\( (\\pi, \\frac{3\\pi}{2}) \\approx (3.14, 4.71) \\) 内，解约在 4.5 附近（因为 \\( x = \\pi \\approx 3.14 \\) 时 \\( \\tan(x) \\approx 0 < x \\)，\\( x = 4.5 \\) 时 \\( \\tan(4.5) \\approx 4.6 > 4.5 \\)? 需计算）。选 \\( x_0 = 4.0 \\)（合理起点）。\n- 迭代格式：\\( x_{n+1} = \\arctan(x_n) + \\pi \\)。\n- 收敛准则：当连续迭代差 \\( |x_{n+1} - x_n| < \\epsilon \\) 时停止，取 \\( \\epsilon = 10^{-4} \\)（常用公差）。\n- 计算工具：使用计算器或软件计算 \\( \\arctan \\)（注意用弧度制）。\n\n#### 步骤 4: 执行迭代计算\n- **迭代 1**：\\( x_0 = 4.0 \\)\n  - \\( \\arctan(4.0) \\approx 1.3258 \\)（因为 \\( \\tan(1.3258) \\approx 4.0 \\))\n  - \\( x_1 = \\arctan(4.0) + \\pi \\approx 1.3258 + 3.1416 = 4.4674 \\)\n- **迭代 2**：\\( x_1 = 4.4674 \\)\n  - \\( \\arctan(4.4674) \\approx 1.3503 \\)（计算：\\( \\tan(1.3503) \\approx 4.4674 \\)，用插值或近似）\n  - \\( x_2 = 1.3503 + 3.1416 = 4.4919 \\)\n- **迭代 3**：\\( x_2 = 4.4919 \\)\n  - \\( \\arctan(4.4919) \\approx 1.3514 \\)（类似计算）\n  - \\( x_3 = 1.3514 + 3.1416 = 4.4930 \\)\n- **迭代 4**：\\( x_3 = 4.4930 \\)\n  - \\( \\arctan(4.4930) \\approx 1.35145 \\)（利用导数近似：\\( g'(x) \\approx 0.047 \\)，变化小）\n  - \\( x_4 = 1.35145 + 3.14159 = 4.49304 \\)\n- **迭代 5**：\\( x_4 = 4.49304 \\)\n  - \\( \\arctan(4.49304) \\approx 1.35148 \\)\n  - \\( x_5 = 1.35148 + 3.14159 = 4.49307 \\)\n\n检查收敛：\\( |x_5 - x_4| = |4.49307 - 4.49304| = 0.00003 < 10^{-4} \\)，停止。\n\n**近似解**：\\( x \\approx 4.4931 \\)。更精确值可用更多迭代或数值方法验证（实际解约 4.4934）。\n\n#### 步骤 5: 验证解\n- 代入原方程：\\( x \\approx 4.4931 \\)，\\( \\tan(4.4931) \\approx ? \\)\n  - 计算 \\( \\tan(4.4931) \\): 4.4931 rad 在第三象限，\\( \\tan(4.4931 - \\pi) \\approx \\tan(1.3515) \\approx 4.493 \\)（因为 \\( \\arctan(4.493) \\approx 1.3515 \\))。\n  - 所以 \\( \\tan(4.4931) \\approx 4.4931 \\)，满足 \\( x = \\tan(x) \\)。\n\n#### 总结思维过程\n- **问题分析**：先理解方程和区间，排除无解子区间，确认解的存在唯一性。\n- **选择 \\( g(x) \\)**：直接迭代可能发散，通过函数变换（利用周期性、导数分析）确保 \\( |g'(x)| < 1 \\)。\n- **迭代实现**：选初始值、迭代计算、监控收敛。\n- **关键点**：不动点迭代成功依赖于 \\( g(x) \\) 的选择；数学推导优先于计算；通过逐步迭代体会收敛性。\n\n此方法可推广到其他方程：重写 \\( x = g(x) \\) 使 \\( g \\) 满足压缩映射条件（\\( |g'(x)| < 1 \\) 且映射区间到自身）。",
      "modelId": "model_1748848200623"
    }
  ],
  "edges": [
    {
      "from": 1,
      "to": 3,
      "id": "483fa00a-e938-41cc-b7b1-38da03e209f6"
    },
    {
      "from": 3,
      "to": 4,
      "id": "8c52bc82-7377-4bfe-8646-6207391a4b91"
    },
    {
      "from": 3,
      "to": 5,
      "id": "d7b0c474-977a-4238-87c0-dfcf4bec4996"
    },
    {
      "from": 3,
      "to": 7,
      "id": "eb74b7e5-51ad-46f9-b131-83aec2dc503f"
    }
  ],
  "nodeIdCounter": 8
}